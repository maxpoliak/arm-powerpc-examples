
##########################################################################
# Макросы, позволяющие сохранить слово (полуслово, байт) val по адресу   #
# addr в памяти                                                          #
##########################################################################

str_word:        .macro  addr, val

    lis  r3, &val&@h
    ori  r3, &val&@l

    lis  r4, &addr&@h
    stw  r3, &addr&@l(r4)

    .endm


str_hword:       .macro  addr, val

    li  r3, &val&

    lis  r4, &addr&@h
    sth  r3, &addr&@l(r4)

    .endm

str_byte:        .macro  addr, val

    li  r3, &val&

    lis  r4, &addr&@h
    stb  r3, &addr&@l(r4)

    .endm


##########################################################################
# Мой пример. Макросы, позволяющие загрузить слово (полуслово, байт) val #
#             из адреса addr адресного пространста в РОН с номером reg   #
#             ПРИМЕЧАНИЕ! reg!=0 || reg!=30                              #
##########################################################################

ld_byte:         .macro  reg, addr

    lis  30, &addr&@h
    lbz  &reg&, &addr&@l(30)

    .endm

ld_hword:        .macro  reg, addr

    lis  30, &addr&@h
    lhz  &reg&, &addr&@l(30)

    .endm

ld_word:         .macro  reg, addr

    lis  30, &addr&@h
    lwz  &reg&, &addr&@l(30)

    .endm

##########################################################################
# пример. Складывает два числа в пямяти                                  #
#                                                                        #
##########################################################################

.section        .text ,"ax"

.data

data1: .word  0x11111111
data2: .word  0x22222222

.text

        .global sum_s

sum_s:

    lis  r3, data1@h                  # Загружаем в r3 младшие 16 бит адреса data1 и сдвигаем их влево на 16 разрядов
    lwz  r4, data1@l(r3)              # обращаемся по адресу в r3 со смещением = младшим 16 битам адреса data1, и
                                      # копируем значение по результирующему адресу в РОН r4
    lis  r3, data2@h                  # Загружаем в r3 младшие 16 бит адреса data2 и сдвигаем их влево на 16 разрядов
    lwz  r5, data2@l(r3)              # обращаемся по адресу в r3 со смещением = младшим 16 битам адреса data2, и
                                      # копируем значение по результирующему адресу в РОН r5
    add  r3, r4, r5                   # складываем значения в r5 и r4, а результат помещаем обратно в r3
    mr  r0,r3                         # копия результата в r0

    blr                               # переход обратно по регистру связи

.end


##########################################################################
#     пример. Макрос. Устанавливает соответствующий бит в слове          #
#             addr - адрес слова в адресном пространстве                 #
#             numbit - номер устанавливаемого бита                       #
#             Задействованы следующие регистры:                          #
#             r1 - хранит адрес слова (addr) в адресном пространстве     #
#             r2 - хранит слово                                          #
#             r3 - хранит сформированную маску                           #
#                                                                        #
# ВНИМАНИЕ!!! BE !                                                       #
#                                                                        #
##########################################################################


SET_BIT_WORD:  .macro  addr, numbit

    lis       r1, &addr&@h            # Загрузить в r1 адрес, а в r4 значение
    ori       r1, r1, &addr&@l        # по этому адресу
    lwz       r2, 0(r1)
    lis       r3, 0x1000              # записать в r3 "0x80000000" и сдвинуть

  .if &numbit& != 0

    srwi      r3,r3, &numbit&         # на numbit разрядов вправо!!!

  .endif

    or        r2, r2, r3              # масикируем r2 c помощью r3 и
                                      # результат в r3
.endm


##########################################################################
#                                                                        #
#     пример. Макрос. Очищает соответствующий бит в слове                #
#             addr - адрес слова в адресном пространстве                 #
#             numbit - номер очищаемого бита                             #
#             Задействованы следующие регистры:                          #
#             r1 - хранит адрес слова (addr) в адресном пространстве     #
#             r2 - хранит слово                                          #
#             r3 - хранит сформированную маску                           #
#                                                                        #
# ВНИМАНИЕ!!! BE !                                                       #
#                                                                        #
##########################################################################


CLI_BIT_WORD:  .macro  addr, numbit

    lis       r1, &addr&@h            # Загрузить в r1 адрес, а в r2 значение
    ori       r1, r1, &addr&@l        # по этому адресу
    lwz       r2, 0(r1)
    lis       r3, 0x1000              # записать в r3 "0x80000000" и сдвинуть
                                      # на numbit разрядов вправо!
  .if &numbit& != 0

    srwi      r3,r3, &numbit&

  .endif

    nor       r3, r3, r3              # побитная инверсия маски в r3
    and       r2, r2, r3              # маскируем r2 c помощью r3 и результат
                                      # в r2
.endm

##########################################################################
#                                                                        #
#     пример. Макрос. Очищает соответствующий бит в слове                #
#             addr - адрес слова в адресном пространстве                 #
#             numbit - номер очищаемого бита                             #
#             Задействованы следующие регистры:                          #
#             r1 - хранит адрес слова (addr) в адресном пространстве     #
#             r2 - хранит слово                                          #
#             r3 - хранит сформированную маску                           #
#                                                                        #
#             Возвращает:                                                #
#             r1 - возвращает состояние выбранного бита                  #
#                                                                        #
# ВНИМАНИЕ!!! Для ядра E500MC - BE !                                     #
#                                                                        #
##########################################################################

CHECK_BIT_WORD:  .macro  addr, numbit

    lis       r1, &addr&@h            # Загрузить в r1 адрес, а в r2 значение
    ori       r1, r1, &addr&@l        # по этому адресу
    lwz       r2, 0(r1)               # загрузить в r2 слово из адреса в r1
    lis       r3, 0x1000              # записать в r3 "0x80000000" и сдвинуть
                                      # на numbit разрядов вправо!
  .if &numbit& != 0

    srwi      r3, r3, &numbit&

  .endif

    srwi      r1, r3, 31 - &numbit&   # сдвинуть на оставшиеся разряды
                                      # вправо, результат поместить в r1
.endm

##########################################################################
#                                                                        #
#     пример. Макрос. Устанавливает биты в слове в соответствии с маской #
#             Задействованы следующие регистры:                          #
#             addr - адрес слова в адресном пространстве                 #
#             mask - битовая маска для установки битов                   #
#                                                                        #
#             r1 - хранит addr                                           #
#             r2 - хранит mask                                           #
#             r3 - хранит адрес слова (addr) в адресном пространстве     #
#                                                                        #
##########################################################################


SET_MASK_WORD:  .macro  addr, mask

    lis       r1, &addr&@h            # Загрузить в r1 адрес addr
    ori       r1, r1, &addr&@l
    lis       r2, &mask&@h            # Загрузить в r2 маску
    ori       r2, r2, &mask&@l

    lwz       r3, 0(r1)               # Загрузить слово из адреса в памяти в r1 (addr)
    or        r3, r3, r2              # Применяем логическую маску
    stw       r3, 0(r1)               # Записать результат по адресу в памяти в r1 (addr)

.endm


##########################################################################
#     пример. Макрос. Очищает биты в слове в соответствии с маской       #
#             Очищаются биты, которые установлены в маске в "1"          #
#             Задействованы следующие регистры:                          #
#             addr - адрес слова в адресном пространстве                 #
#             mask - битовая маска для установки битов                   #
#             r1 - хранит addr                                           #
#             r2 - хранит mask                                           #
#             r3 - хранит адрес слова (addr) в адресном пространстве     #
##########################################################################


SET_MASK_WORD:  .macro  addr, mask

    lis       r1, &addr&@h            # Загрузить в r1 адрес addr
    ori       r1, r1, &addr&@l
    lis       r2, &mask&@h            # Загрузить в r2 маску
    ori       r2, r2, &mask&@l
    nor       r2, r2, r2
    lwz       r3, 0(r1)               # Загрузить слово из адреса в памяти в r1 (addr)
    and       r3, r3, r2              # Применяем логическую маску
    stw       r3, 0(r1)               # Записать результат по адресу в памяти в r1 (addr)

.endm

##########################################################################
#                                                                        #
#     пример. Подпрограмма SetArray позволяет проинициализировать каждый #
#             элемент массива целых чисел определенным значением,которое #
#             может определяться какой-либо формулой.Последнему элементу #
#             массива присваивается 0, а каждый предыдущий элемент       #
#             принимает значение на 3 больше последующего.               #
#             Принимает параметры:                                       #
#             r1 - * pArray- указатель на размещение массива целых чисел #
#             r2 - количество чисел в массиве                            #
#             Используемые параметры :                                   #
#             r3 - временный регистр                                     #
#                                                                        #
##########################################################################

.section        .text ,"ax"

.text

      .global  SetArray

SetArray:

    slwi      r3, r2, 2               # умножаем r2 на 4, а результат в r3
    xor       r2, r2, r2              # очистить r2 в 0
    stwx      r2, r3, r1              # загрузить в r2 значение по адресу из r1
                                      # со смещением количества слов в массиве
loop_SetArray:

    subfic    r3, r3, 4               # декрементировать указатель цепочки на 4
    addi      r2, r2, 3               # инкрементировать слово в очередном элементе массива
    stwx      r2, r3, r1              # и записать его обратно по указателю в r4
    cmpwi     r4, 0                   # сравнить r4 с 0
    bne       loop_SetArray           # пока не равно, зацикливаем на loop_SetArray

    blr                               # возвратиться в основную процедуру
                                      # т.е. перейти по адресу, записанному в регистре связи

.end


##########################################################################
#                                                                        #
#     пример. Подпрограмма SetArray позволяет проинициализировать каждый #
#             элемент массива целых чисел определенным значением,которое #
#             может определяться какой-либо формулой.Здесь наоборот!     #
#             Первому элементу массива присваивается 0, а каждый         #
#             последующий элемент примнимает значение на 3 больше        #
#             последующего.                                              #
#             Принимает параметры:                                       #
#             r1 - * pArray- указатель на размещение массива целых чисел #
#             r2 - количество чисел в массиве                            #
#             Возвращает параметры :                                     #
#             r1 - Указатель на последний элемент массива                #
#                                                                        #
##########################################################################


.section        .text ,"ax"

.text

      .global  SetArray

SetArray:

    mtctr     r2                      # заполнить внутренний регистр-счетчик
    xor       r2, r2, r2              # очистить РОН номер 2
    stw       r2, 0(r1)               # записать нулевое значение по адресу

loop_SetArray:

    addi      r2, r2, 1               # увеличить содержимое регистра r2 на 3
    stwu      r2, 4(r1)               # записать значение в r2 по адресу в r1
                                      # c предекрементом, сохранить измененный адрес в r1
    bdnz      loop_SetArray           # уменьшить регистр-счетчик и перейти, если он не стал равен 0
    blr                               # вернуться в главную подпрограмму по адресу из регистра связи

.end


##########################################################################
#                                                                        #
#     пример. Подпрограмма MaxWordArray позволяет выявить максимальное   #
#             число массива                                              #
#                                                                        #
#             Принимает параметры:                                       #
#             r1 - * pArray- указатель на размещение массива целых чисел #
#             r2 - количество чисел в массиве                            #
#             rl - адрес возврата к основной подпрограмме                #
#                                                                        #
#             использует в процессе:                                     #
#             r3 - временный регистр для элементов массива               #
#             ctr- внутренний регистр-счетчик ядра                       #
#                                                                        #
#             Возвращает параметры:                                      #
#             r1 - Максимальное слово в массиве                          #
#                                                                        #
##########################################################################

.section        .text ,"ax"

.text

      .global  MaxWordArray

MaxWordArray:
    cmplwi    r2, 0                   # если введено нулевое количество элементов,
    beq       exit_MaxWordArray       # выходим из процедуры, возвращаем 0
    mtctr     r2                      # заполнить внутренний регистр-счетчик
    bdz       exit_MaxWordArray       # уменьшить регистр-счетчик. если 0 - выйти
                                      # и вернуть 0
first_max_word:
    lwz       r2, 0(r1)               # записать в r2 первый элемент массива

loop_MaxWordArray:
    lwzu      r3, 4(r1)               # записать в r3 следующий элемент массива
    cmpw      r3, r2                  # сравнить r3 с r2, если меньше или
    ble       not_max_word            # равно, то перейти к not_max_word
    mr        r2, r3                  # копировать в r2 наибольшее значение

not_max_word:
    bdnz      loop_MaxWordArray       # уменьшить регистр-счетчик и перейти на
                                      # loop, если он не стал равен 0
exit_MaxWordArray:
    mr        r1, r2                  # если в массиве одно число, копируем его в
    blr                               # регистр результата и выходим из процедуры

.end


##########################################################################
#                                                                        #
#     пример. Процедура SeekRange позволяет подсчитать количество чисел, #
#             попадающих в заданный диапазон                             #
#                                                                        #
#             Принимает параметры:                                       #
#             r1 - * pArray- указатель на размещение массива целых чисел #
#             r2 - меньшая граница диапазона                             #
#             r3 - большая граница диапазона                             #
#             r4 - количество чисел в массиве                            #
#             rl - адрес возврата к основной подпрограмме                #
#                                                                        #
#             использует в процессе:                                     #
#             r5 - временный счетный регистр для элементов массива       #
#             ctr- внутренний регистр-счетчик ядра                       #
#                                                                        #
#             Возвращает параметры:                                      #
#             r1 - количество слов в пределах заданного диапазона        #
#                                                                        #
##########################################################################

.section        .text ,"ax"

.text

      .global  MaxWordArray

SeekRange:
    xor       r5, r5, r5              # очистить содержимое r5 в 0
    cmplwi    r4, 0                   # если задано нулевое количество элементов
    beq       exit_SeekRange          # выходим из процедуры и возвращаем нулевое значение
    mtctr     r4                      # заполняем содержимое системного счетчика.
    lwz       r4, 0(r1)               # считать в r4 содержимое по адресу в r1

loop_SeekRange:
    cmpw      r4, r3                  # сравнить с верхней границей
    ble       lower_border_range      # если <=, то переходим к сравнению с нижней
    b         next_word               # в противном случае выходим из цикла

lower_border_range:
    cmpw      r4, r2                  # сравнить с нижней границей:
    blt       next_word               # если меньше, то переходим к next_word
    addi      r5, r5, 1               # в противном случае - инкрементируем значение
    b         next_word               # счетчика и все равно переходим к next_word

next_word:
                                      # декрементировать системный счетчик и
    bdz       exit_SeekRange          # выйти, если его содержимое = 0
    lwzu      r4, 4(r1)               # загрузка со смещением и модиф. адреса
    b         loop_SeekRange          # перейти в начало цикла

exit_SeekRange:
    mr        r1, r5                  # Скопировать результат в регистр r1 и перейти
    blr                               # по адресу возврата из процедуры в регистре lr

.end


##########################################################################
#                                                                        #
#    пример. Процедура RevWordArray, подсчитывающая количество отрица-   #
#             тельных чисел, попадающих в заданный диапазон, записыват   #
#             их в отдельный массив, а затем инвертирует в основном.     #
#             ТРЕБОВАНИЕ!Количество элементов каждого из массивов должно #
#             быть задано в нулевом элементе:                            #
#                                                                        #
#             typedef struct                                             #
#             {                                                          #
#               WORD   size;                                             #
#               SWORD  mass[size];                                       #
#             } tARRAY;                                                  #
#                                                                        #
#             Принимает параметры:                                       #
#             r1 - * pArray- указатель на размещение массива целых чисел #
#             r2 - * pArray- указатель на массив отрицательных чисел     #
#             rl - адрес возврата к основной подпрограмме                #
#                                                                        #
#             использует в процессе:                                     #
#             r3 - регистр количества эрементов осн. массива             #
#             r4 - регистр количества эрементов доп. массива             #
#             r5 - временный счетный регистр для элементов массива       #
#             r6 - хранит копию lr сразу после входа в процедуру         #
#             ctr- внутренний регистр-счетчик ядра                       #
#                                                                        #
#             Возвращает параметры:                                      #
#             r1 - количество отрицательных чисел                        #
#                                                                        #
##########################################################################

RevWordArray:

    mflr      r6                      # сохранить адрес возврата из процедуры в r6
    lis       r5, negative_num@h      # сохранить в регистре r5 адрес процедуры negative_num,
    ori       r5, r5, negative_num@l  # которая производит обработку найденных в основном массиве
    mtlr      r5                      # отрицательных чисел, и копировать его в регистр связи lr
    xor       r5, r5, r5              # очистить регистр r5 в 0
    lwz       r3, 0(r1)               # Скопировать в r3 количество элементов в основном массиве
    cmplwi    r3, 0                   # Проверить, не является ли значение нулевым
    beq       exit_RevWordArray       # если 0, то перейти к err_RevWordArray
    lwz       r4, 0(r2)               # Скопировать в r4 количество элементов в доп.массиве
    cmplwi    r4, 0                   # Проверить, не является ли значение нулевым
    beq       exit_RevWordArray       # если 0, то перейти к err_RevWordArray
    mtctr     r3                      # заполнить системный счетчик значением из r3

loop_RevWordArray:
    lwzu      r3, 4(r1)               # копировать в r3 очередное значение основного массива
                                      # с модификацией и сохранением адреса в r1
    cmpwi     r3, 0                   # проверить, не является ли значение <0, и если так, то
    bltlr                             # перейти по адресу в lr
    bdnz      loop_RevWordArray       # декрементировать системный счетчик, и если его
                                      # значение != 0, то перейти к loop_RevWordArray
exit_RevWordArray:
    mtlr      r6                      # восстанавливаем адрес возврата из процедуры в осн. программу
    mr        r1, r5                  # копируем результат в регистр r1
    blr                               # выполняем переход к осн. программе по адресу в lr

negative_num:
    addi      r5, r5, 1               # инкрементировать счетный регистр r5
    stwu      r3, 4(r2)               # сохраняем отрицательное число в доп. массиве.(МА)
    neg       r3, r3                  # меняем знак и сохраняем в основном массиве
    stw       r3, 0(r1)               # сохраняем отрицательное число в доп. массиве(без МА)
    cmplw     r5, r4                  # проверяем, все ли ячейки в доп.массиве заполнены, и
    blt       loop_RevWordArray       # если они не заполены, то перейти в начало цикла
    lis       r4, alternative_num@h   # в противном случае загружаем в r4 адрес альтернативной
    ori       r4, r4,alternative_num@l# процедуры обработки цисел и копируем его в регистр
    mtlr      r4                      # связи lr. И УЖЕ В СЛЕДУЮЩИЙ РАЗ, в результате команды
                                      # bltlr будет вызываться подпроцедура alternative_num !!!
    b         loop_RevWordArray       # безусловный переход в начало цикла

alternative_num:
    addi      r5, r5, 1               # инкрементировать счетный регистр r5
    neg       r3, r3                  # меняем знак и сохраняем в основном массиве
    stw       r3, 0(r1)               # сохраняем отрицательное число в доп. массиве(без МА)
    b         loop_RevWordArray       # безусловный переход в начало цикла


##########################################################################
#              Программа осуществляет суммирование двух чисел в памяти   #
#             .proc  sum                                                 #
##########################################################################

.ppc64

# Раздел данных
.data
.align  3               #устанавлиавет 8-байтовые границы

#.quad - порождает 8-байтовый объект
first_value:
        .quad 1
second_value:
        .quad 2

.section ".opb", "aw"
.align  3               #устанавлиавет 8-байтовые границы

# описание процедуры для ._start
.global _start
# Отметим, что описание кода называется _start, а начало кода - ._start

_start:
         .quad  ._start, .TOC.@tocbace, 0

# Перейдем к разделу "text" кода программы
.text
._start:

    # используем регистр 7 для загрузки адреса
    # 64-битный адрес должен загружаться частями по 16 бит

    # Загружаем верхние части адреса
    lis  7, first_value@higest
    ori  7, 7, first_value@higer
    # Сдвигаем их в верхнюю часть
    rldicr  7, 7, 32, 31
    # загружаем нижние части адреса
    oris  7, 7, first_value@h
    ori   7, 7, first_value@l

    # загружаем первое значение в регистр 4 из адреса, который только
    # что загрузили в РОН №7
    ld  4, 0(7)

    # загружаем адрес для второго значения

    # Загружаем верхние части адреса
    lis  7, second_value@higest
    ori  7, 7, second_value@higer
    # Сдвигаем их в верхнюю часть
    rldicr  7, 7, 32, 31
    # загружаем нижние части адреса
    oris  7, 7, second_value@h
    ori   7, 7, second_value@l

    # загружаем первое значение в регистр 5 из адреса, который только
    # что загрузили в РОН №7
    ld  5, 0(7)

    # вычисляем значение и сохраняем его в РОН 6
    add  6, 4, 5

    # завершаем программу с кодом возврата
    li  0, 1        # системный вызов помещаем в регистр 0
    mr  3, 6        # копируем результат в регистр 3 для системного вызова

    sc              # системный вызов ядру ОС

##########################################################################